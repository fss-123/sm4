#include <stdio.h>
#include <stdint.h>

#define SM4_POLY 0xF5

// --- Part 1: Day 1 已实现的乘法函数 (直接复用) ---
uint8_t gf28_multiply(uint8_t a, uint8_t b) {
    uint8_t p = 0;
    uint8_t i;
    for (i = 0; i < 8; i++) {
        if (b & 1) p ^= a;
        uint8_t high_bit = a & 0x80;
        a <<= 1;
        if (high_bit) a ^= SM4_POLY;
        b >>= 1;
    }
    return p;
}

// --- Part 2: Day 2 新增核心 - 求逆元函数 ---
// 原理: 在 GF(2^8) 中, a 的逆元等于 a^(2^8 - 2) = a^254
// 这里使用最简单的"平方乘"算法(Square and Multiply)或直接循环乘
uint8_t gf28_inverse(uint8_t a) {
    // 0 的逆元定义为 0
    if (a == 0) return 0;

    uint8_t result = 1;
    uint8_t base = a;
    // 指数是 254 (二进制 1111 1110)
    // 我们可以简单地连乘 254 次，或者用下面的快速幂算法
    
    // 快速幂计算 base^254
    // 254 = 128 + 64 + 32 + 16 + 8 + 4 + 2
    int exponent = 254;
    while (exponent > 0) {
        if (exponent & 1) {
            result = gf28_multiply(result, base);
        }
        base = gf28_multiply(base, base); // 平方
        exponent >>= 1;
    }
    return result;
}

// --- Part 3: 国密标准 SM4 S盒 (Standard S-Box) ---
// 这个表必须和标准文档一字不差。Day 3 我们会把这个移到 sm4.c 里。
static const uint8_t SM4_SBOX[256] = {
    0xd6,0x90,0xe9,0xfe,0xcc,0xe1,0x3d,0xb7,0x16,0xb6,0x14,0xc2,0x28,0xfb,0x2c,0x05,
    0x2b,0x67,0x9a,0x76,0x2a,0xbe,0x04,0xc3,0xaa,0x44,0x13,0x26,0x49,0x86,0x06,0x99,
    0x9c,0x42,0x50,0xf4,0x91,0xef,0x98,0x7a,0x33,0x54,0x0b,0x43,0xed,0xcf,0xac,0x62,
    0xe4,0xb3,0x1c,0xa9,0xc9,0x08,0xe8,0x95,0x80,0xdf,0x94,0xfa,0x75,0x8f,0x3f,0xa6,
    0x47,0x07,0xa7,0xfc,0xf3,0x73,0x17,0xba,0x83,0x59,0x3c,0x19,0xe6,0x85,0x4f,0xa8,
    0x68,0x6b,0x81,0xb2,0x71,0x64,0xda,0x8b,0xf8,0xeb,0x0f,0x4b,0x70,0x56,0x9d,0x35,
    0x1e,0x24,0x0e,0x5e,0x63,0x58,0xd1,0xa2,0x25,0x22,0x7c,0x3b,0x01,0x21,0x78,0x87,
    0xd4,0x00,0x46,0x57,0x9f,0xd3,0x27,0x52,0x4c,0x36,0x02,0xe7,0xa0,0xc4,0xc8,0x9e,
    0xea,0xbf,0x8a,0xd2,0x40,0xc7,0x38,0xb5,0xa3,0xf7,0xf2,0xce,0xf9,0x61,0x15,0xa1,
    0xe0,0xae,0x5d,0xa4,0x9b,0x34,0x1a,0x55,0xad,0x93,0x32,0x30,0xf5,0x8c,0xb1,0xe3,
    0x1d,0xf6,0xe2,0x2e,0x82,0x66,0xca,0x60,0xc0,0x29,0x23,0xab,0x0d,0x53,0x4e,0x6f,
    0xd5,0xdb,0x37,0x45,0xde,0xfd,0x8e,0x2f,0x03,0xff,0x6a,0x72,0x6d,0x6c,0x5b,0x51,
    0x8d,0x1b,0xaf,0x92,0xbb,0xdd,0xbc,0x7f,0x11,0xd9,0x5c,0x41,0x1f,0x10,0x5a,0xd8,
    0x0a,0xc1,0x31,0x88,0xa5,0xcd,0x7b,0xbd,0x2d,0x74,0xd0,0x12,0xb8,0xe5,0xb4,0xb0,
    0x89,0x69,0x97,0x4a,0x0c,0x96,0x77,0x7e,0x65,0xb9,0xf1,0x09,0xc5,0x6e,0xc6,0x84,
    0x18,0xf0,0x7d,0xec,0x3a,0xdc,0x4d,0x20,0x79,0xee,0x5f,0x3e,0xd7,0xcb,0x39,0x48
};

// --- Part 4: 仿射变换 (Affine Transform) ---
// SM4 S盒 = 逆元 + 仿射变换
// 公式: y = L(x) + C
// 注意：SM4 的具体仿射参数通常直接固化在 SBOX 表里，
// 这里我们主要验证 S盒的"非线性"特性，即 逆元计算是否正确。
// 如果你想完全手算生成上面的表，需要复杂的矩阵乘法，
// 工程上，我们直接使用上面的表，但我们要验证"0x00的输出"等特性。

int main() {
    printf("=== Day 2: S-Box Verification ===\n");

    // 1. 验证逆元函数
    // 随便找个数，比如 0x57
    uint8_t a = 0x57;
    uint8_t inv = gf28_inverse(a);
    uint8_t product = gf28_multiply(a, inv);
    
    printf("[Math Check] Inverse of 0x%02x is 0x%02x\n", a, inv);
    printf("[Math Check] Verification: 0x%02x * 0x%02x = 0x%02x (Should be 0x01)\n", a, inv, product);

    if (product == 1) {
        printf(" -> Inverse function works correctly!\n");
    } else {
        printf(" -> ERROR: Inverse function failed.\n");
    }

    // 2. 验证 S盒的特殊值
    // 计划中提到: 输入 0x00 -> 输出 0xD6
    // 原理: 0 的逆元是 0。仿射变换(0) + 0xD6 = 0xD6。
    printf("\n[S-Box Check] SBOX[0x00] = 0x%02x (Expected: 0xD6)\n", SM4_SBOX[0x00]);
    
    // 验证另一个值，比如 SBOX[0x01]
    printf("[S-Box Check] SBOX[0x01] = 0x%02x\n", SM4_SBOX[0x01]);

    printf("\n[Done] S-Box table is ready for Day 3 integration.\n");

    return 0;
}